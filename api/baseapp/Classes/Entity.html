<html>
<head>
<title>Entity - KBEngine base 文档</title>
<link href="../../style.css" rel="stylesheet" type="text/css">
</head>
<body>
<table width="100%" border="0" cellpadding="0" cellspacing="0">
<tr><td align=left style="background:#708090"> <font size=15 color=#ffffff> KBEngine </font></td></tr>
</table> <hr>
<h1>Entity类</h1>

<p style="text-align: center;"><span class="module_h1">[<a href="../Modules/KBEngine.html" class="module_h1">KBEngine模块</a>]</span></p><p>Entity是<a href="../Modules/KBEngine.html">KBEngine</a>模块的一部分。 <a href="#detailed_description">更多...</a></p><p></p><pre>import KBEngine</pre>

<h2><a href="#" onClick="obj=document.getElementById( 'functions' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">成员函数</a></h2>
<table id="functions" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr><td>
<span class="function_list">def <a href="#addTimer" class="function_list" >addTimer</a>( self, initialOffset, repeatOffset=0, userArg=0 ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#createCellEntity" class="function_list" >createCellEntity</a>( self, cellEntityMB ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#createCellEntityInNewSpace" class="function_list" >createCellEntityInNewSpace</a>( self, cellappIndex ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#delTimer" class="function_list" >delTimer</a>( self, id ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#destroy" class="function_list" >destroy</a>( self, deleteFromDB, writeToDB ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#destroyCellEntity" class="function_list" >destroyCellEntity</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#teleport" class="function_list" >teleport</a>( self, baseEntityMB ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#writeToDB" class="function_list" >writeToDB</a>( self, callback, shouldAutoLoad, dbInterfaceName ):</span>
</td></tr>

</table>

<h2><a href="#" onClick="obj=document.getElementById( 'callbacks' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">回调函数</a></h2>
<table id="callbacks" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr><td>
<span class="function_list">def <a href="#onCreateCellFailure" class="function_list" >onCreateCellFailure</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onDestroy" class="function_list" >onDestroy</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onGetCell" class="function_list" >onGetCell</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onLoseCell" class="function_list" >onLoseCell</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onPreArchive" class="function_list" >onPreArchive</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onRestore" class="function_list" >onRestore</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onTimer" class="function_list" >onTimer</a>( self, timerHandle, userData ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onTeleportFailure" class="function_list" >onTeleportFailure</a>( self ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onTeleportSuccess" class="function_list" >onTeleportSuccess</a>( self, nearbyEntity ):</span>
</td></tr>

<tr><td>
<span class="function_list">def <a href="#onWriteToDB" class="function_list" >onWriteToDB</a>( self, cellData ):</span>
</td></tr>

</table>

<h2><a href="#" onClick="obj=document.getElementById( 'attributes' );vis = (obj.style.display == 'none') ? 'block' : 'none'; obj.style.display = vis; return false;" class="h2">属性</a></h2>
<table id="attributes" cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><a href="#cell" class="attribute_list" >cell</a></td><td>&nbsp; 只读 <a href=../../keywords.html#EntityCall>CellEntityCall</a>
</td></tr>

<tr valign=top><td><a href="#cellData" class="attribute_list" >cellData</a></td><td>&nbsp; <a href="CELLDATADICT.html">CELLDATADICT</a>
</td></tr>

<tr valign=top><td><a href="#className" class="attribute_list" >className</a></td><td>&nbsp; 只读 <a href="STRING.html">string</a>
</td></tr>

<tr valign=top><td><a href="#client" class="attribute_list" >client</a></td><td>&nbsp; 只读 <a href=../../keywords.html#EntityCall>ClientEntityCall</a>
</td></tr>

<tr valign=top><td><a href="#databaseID" class="attribute_list" >databaseID</a></td><td>&nbsp; 只读 <a href="int64.html">int64</a>
</td></tr>

<tr valign=top><td><a href="#databaseInterfaceName" class="attribute_list" >databaseInterfaceName</a></td><td>&nbsp; 只读 <a href="STRING.html">string</a>
</td></tr>

<tr valign=top><td><a href="#id" class="attribute_list" >id</a></td><td>&nbsp; 只读 <a href="int32.html">int32</a>
</td></tr>

<tr valign=top><td><a href="#isDestroyed" class="attribute_list" >isDestroyed</a></td><td>&nbsp; <a href="bool.html">bool</a>
</td></tr>

<tr valign=top><td><a href="#shouldAutoArchive" class="attribute_list" >shouldAutoArchive</a></td><td>&nbsp; True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>

<tr valign=top><td><a href="#shouldAutoBackup" class="attribute_list" >shouldAutoBackup</a></td><td>&nbsp; True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>

</table>

<hr>
<a name="detailed_description"></a><h2>详细描述</h2>
<a href="Entity.html">Entity</a>类代表一个驻留在<a href="../index.html">Baseapp</a>上的实体。 <a href="Entity.html">Entity</a>
实体可以通过<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#createEntity>createEntity</a>函数(以及以createEntity为前缀的函数)创建。一个<a href="Entity.html">Entity</a>实体也可以通过<a href="../../cellapp/index.html">Cellapp</a>的函数<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=../../cellapp/Modules/KBEngine.html#createEntityOnBaseApp>createEntityOnBaseApp</a>远程创建。
<br><br>
一个<a href="Entity.html">Entity</a>实体可以在一个活动的<a href=../../keywords.html#cell>cells</a>里面链接到一个实体，还可以被用来在一个合适的<a href=../../keywords.html#cell>cell</a>上创建一个关联的实体。
这个类允许你创建和销毁在<a href=../../keywords.html#cell>cell</a>上的实体或者在base实体上注册一个定时器也或者访问此对象的联系信息，<br>
还可以访问一个<a href="../../keywords.html#EntityCall">CellEntityCall</a>，通过它这个base实体可以与它的<a href=../../keywords.html#cell>cell</a>实体通信（这个被关联的<a href=../../keywords.html#cell>cell</a>实体可以移动到不同<a href=../../keywords.html#cell>cell</a>上，作为该<a href=../../keywords.html#cell>cell</a>实体移动的结果KBEngine会进行负载均衡）。

<hr>
<h2>成员函数文档</h2>

<a name="addTimer"></a><p class="function_definition">
<span class="function_definition">def addTimer( <i>self, initialOffset, repeatOffset=0, userArg=0</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
注册一个定时器，定时器由回调函数<i><a href="#onTimer">onTimer</a></i>触发，回调函数将在"initialOffset"秒后被执行第1次，而后将每间隔"repeatOffset"秒执行1次，可设定一个用户参数"userArg"（仅限integer类型）。
<br><br>
<i><a href="#onTimer">onTimer</a></i> 函数必须在entity的base部分被定义，且带有2个参数，第1个integer类型的是timer的id（可用于移除timer的"<a href="#delTimer">delTimer</a>"函数），第2个是用户参数"userArg"。
<br><br>
例子:

<pre><pre># 这里是使用addTimer的一个例子
import <a href="../Modules/KBEngine.html">KBEngine</a>
&nbsp;
class MyBaseEntity( <a href="../Modules/KBEngine.html">KBEngine</a>.<a href="Entity.html">Entity</a> ):
&nbsp;
    def __init__( self ):
        <a href="../Modules/KBEngine.html">KBEngine</a>.<a href="Entity.html">Entity</a>.__init__( self )
&nbsp;
        # 增加一个定时器，5秒后执行第1次，而后每1秒执行1次，用户参数是9
        self.addTimer( 5, 1, 9 )
&nbsp;
        # 增加一个定时器，1秒后执行，用户参数缺省是0
        self.addTimer( 1 )
&nbsp;
    # <a href="Entity.html">Entity</a>的定时器回调"onTimer"被调用
    def onTimer( self, id, userArg ):
        print "MyBaseEntity.onTimer called: id %i, userArg: %i" % ( id, userArg )
        # if 这是不断重复的定时器，当不再需要该定时器的时候，调用下面函数移除:
        #     self.delTimer( id )</pre>
</pre>
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>initialOffset</i></span></td><td><span class="function_parameter_description">
float，指定定时器从注册到第一次回调的时间间隔（秒）。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>repeatOffset</i></span></td><td><span class="function_parameter_description">
float，指定第一次回调执行后每次执行的时间间隔（秒）。必须用函数<a href="#delTimer">delTimer</a>移除定时器，否则它会一直重复下去。值小于等于0将被忽略。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>userArg</i></span></td><td><span class="function_parameter_description">
integer，指定底层回调"<a href="#onTimer">onTimer</a>"时的userArg参数值。
</span></td></tr>

</table>
</p>

<p>
<span class="function_return">返回:</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>integer，该函数返回timer的内部id，这个id可用于<a href="#delTimer">delTimer</a>移除定时器。
</td></tr>
</table>
</p>

<a name="createCellEntity"></a><p class="function_definition">
<span class="function_definition">def createCellEntity( <i>self, cellEntityMB</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
请求在一个<a href=../../keywords.html#cell>cell</a>里面创建一个关联的实体。
<br><br>
用于创建<a href=../../keywords.html#cell>cell</a>实体的信息被存储在该实体的属性cellData里。这个属性是一个字典，对应实体的.def文件里的默认值，同时还包括用于表示<br>
实体位置和方向(roll, pitch, yaw)的"position", "direction" 和 "spaceID"。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>cellEntityMB</i></span></td><td><span class="function_parameter_description">
一个可选的<a href=../../keywords.html#EntityCall>CellEntityCall</a>参数，
指定哪个空间里创建这个cell实体的。
<br><br>
只能使用一个直接的<a href=../../keywords.html#EntityCall>CellEntityCall</a>。如果你有一个实体的<a href=../../keywords.html#EntityCall>BaseEntityCall</a>，你不可以使用<i>baseEntityCall.cell</i>传给这个函数。<br>
你必须在这个实体的base上创建一个新的函数来回传这个直接的<a href=../../keywords.html#EntityCall>CellEntityCall</a>。<br>
<br>
例如：
<pre>baseEntityCallOfNearbyEntity.createCellNearSelf( self )</pre>
在实体的base上：
<pre>def createCellNearSelf( self, baseEntityCall ):
    baseEntityCall.createCellNearHere( self.cell )</pre>
在原实体的base上调用createCellNearSelf()方法：
<pre>def createCellNearHere( self. cellEntityCall ):
    self.createCellEntity( cellEntityCall )</pre>
</span></td></tr>

</table>
</p>

<a name="createCellEntityInNewSpace"></a><p class="function_definition">
<span class="function_definition">def createCellEntityInNewSpace( <i>self, cellappIndex</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
在cellapp上创建一个空间(space)并且将该实体的<a href=../../keywords.html#cell>cell</a>创建到这个新的空间中，它请求通过cellappmgr来完成。
<br><br>
用于创建cell实体的信息被存储在该实体的属性cellData里。这个属性是一个字典，对应实体的.def文件里的默认值同时还包括用于表示<br>
实体位置和方向(roll, pitch, yaw)的"position", "direction" 和 "spaceID"。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>cellappIndex</i></span></td><td><span class="function_parameter_description">
integer，为None或者0则由引擎负载均衡进行动态选择，如果大于0则在指定的cellapp中创建space。<br>
例子：假如预期会开启4个cellapp，那么cellappIndex需要指定时索引可以是1、2、3、4，<br>
如果实际运行的cellapp不足4个，例如只有3个，那么cellappIndex输入4时由于数量溢出4代表1，如果输入5则代表2。<br><br>
提示：此功能可以结合KBngine.setAppFlags(KBEngine.APP_FLAGS_NOT_PARTCIPATING_LOAD_BALANCING)来使用，例如：将大地图space放到几个固定的cellapp中，并将这些cellapp设置为不参与负载均衡，其他cellapp用于放置副本space。
创建副本space时cellappIndex设置为0或者None，副本地图的消耗将不会影响到大地图进程，从而保证了主场景的流畅。
</span></td></tr>

</table>
</p>


<a name="delTimer"></a><p class="function_definition">
<span class="function_definition">def delTimer( <i>self, id</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
函数delTimer用于移除一个注册的定时器，移除后的定时器不再执行。只执行1次的定时器在执行回调后自动移除，不必要使用delTimer移除。
如果delTimer函数使用一个无效的id（例如已经移除），将会产生错误。
<br><br>
到<a href="Entity.html">Entity</a>.<a href=Entity.html#addTimer>addTimer</a>参考定时器的一个使用例子。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>id</i></span></td><td><span class="function_parameter_description">
integer，它指定要移除的定时器id。
</span></td></tr>

</table>
</p>

<a name="destroy"></a><p class="function_definition">
<span class="function_definition">def destroy( <i>self, deleteFromDB, writeToDB</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
这个函数销毁该实体的base部分。如果实体存在cell部分，那么用户必须先销毁cell部分，否则将会产生错误。要销毁实体的cell部分，调用<a href="Entity.html">Entity</a>.<a href=Entity.html#destroyCellEntity>destroyCellEntity</a>。
<br><br>
也许在onLoseCell回调里调用self.destroy更为恰当。这能保证实体的base部分被销毁。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>deleteFromDB</i></span></td><td><span class="function_parameter_description">
如果是True，在数据库里与这个实体有关联的条目将会被删除，该参数默认为False。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>writeToDB</i></span></td><td><span class="function_parameter_description">
如果是True，与这个实体相关联的存档属性将会写入数据库。只有在这个实体是从数据库读取的或者是使用过<a href="Entity.html">Entity</a>.<a href=Entity.html#writeToDB>writeToDB</a>写入数据库才会被执行。这个参数默认为True，但当deleteFromDB为True的时候它将被忽略。
</span></td></tr>

</table>
</p>

<a name="destroyCellEntity"></a><p class="function_definition">
<span class="function_definition">def destroyCellEntity( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
<i>destroyCellEntity</i>请求销毁关联的cell实体。如果没有关联的cell实体该方法将会产生错误。
</div>

<a name="teleport"></a><p class="function_definition">
<span class="function_definition">def teleport( <i>self, baseEntityMB</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
<i>teleport</i>会瞬移这个实体的cell部分到参数指定的实体所在的空间。
<br><br>
在抵达新的空间后，Entity.onTeleportSuccess被调用。这可以用来在新的空间里移动该实体到合适的位置。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>baseEntityMB</i></span></td><td><span class="function_parameter_description">
实体应该移到的指定实体所在的空间，baseEntityMB即指定实体的<a href=../../keywords.html#EntityCall>EntityCall</a>。当成功的时候，与此参数相关联的cell实体会被传入到Entity.onTeleportSuccess函数。
</span></td></tr>

</table>
</p>

<a name="writeToDB"></a><p class="function_definition">
<span class="function_definition">def writeToDB( <i>self, callback, shouldAutoLoad, dbInterfaceName</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
该函数保存这个实体的存档属性到数据库，使得以后需要的时候可以重新从数据库加载。
<br><br>
实体也可以被标记为自动加载，这样当服务启动后实体将会被重新创建。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>callback</i></span></td><td><span class="function_parameter_description">
这个可选参数是当数据库操作完成后的回调函数。
它有两个参数。第一个是boolean类型标志成功或失败，第二个是base实体。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>shouldAutoLoad</i></span></td><td><span class="function_parameter_description">
这个可选参数指定这个实体在服务启动的时候是否需要从数据库加载。<br>
注意：服务器启动时自动加载实体，底层默认将会调用createEntityAnywhereFromDBID将实体创建到一个负载最小的baseapp上，整个过程将会在第一个启动的baseapp调用onBaseAppReady之前完成。<br>
<br>脚本层可以在个性化脚本(kbengine_defaults.xml->baseapp->entryScriptFile定义)中重新实现实体的创建方法，例如：<br>
def onAutoLoadEntityCreate(entityType, dbid): <br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KBEngine.createEntityFromDBID(entityType, dbid)<br>
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>dbInterfaceName</i></span></td><td><span class="function_parameter_description">
string，可选参数，指定由某个数据库接口来完成, 默认使用"default"接口。数据库接口由kbengine_defaults.xml->dbmgr->databaseInterfaces中定义。
</span></td></tr>

</table>
</p>

<hr>
<h2>回调函数文档</h2>

<a name="onCreateCellFailure"></a><p class="function_definition">
<span class="function_definition">def onCreateCellFailure( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在cell实体创建失败的时候被调用。
这个函数没有参数。
</div>

<a name="onDestroy"></a><p class="function_definition">
<span class="function_definition">def onDestroy( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在调用<a href="Entity.html">Entity</a>.<a href=Entity.html#destroy>destroy</a>()后，在实际销毁之前被调用。
这个函数没有参数。
</div>

<a name="onGetCell"></a><p class="function_definition">
<span class="function_definition">def onGetCell( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在它获得cell实体的时候被调用。
这个函数没有参数。
</div>

<a name="onLoseCell"></a><p class="function_definition">
<span class="function_definition">def onLoseCell( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在它关联的cell实体销毁之后被调用。
这个函数没有参数。
</div>

<a name="onPreArchive"></a><p class="function_definition">
<span class="function_definition">def onPreArchive( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在该实体自动写入数据库之前被调用。这个回调在<a href="Entity.html">Entity</a>.<a href=Entity.html#onWriteToDB>onWriteToDB</a>回调之前被调用。<br>
如果该回调返回False，该归档操作中止。这个回调应该返回True使得操作继续。如果这个回调不存在，则归档操作继续进行。
</div>

<a name="onRestore"></a><p class="function_definition">
<span class="function_definition">def onRestore( <i>self</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在<a href="Entity.html">Entity</a>应用程序崩溃后在其它<a href="Entity.html">Entity</a>应用程序上
重新创建该实体时被调用。
这个函数没有参数。
</div>

<a name="onTimer"></a><p class="function_definition">
<span class="function_definition">def onTimer( <i>self, timerHandle, userData</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
这个函数当一个与此实体关联的定时器触发的时候被调用。
一个定时器可以使用<a href="Entity.html">Entity</a>.<a href=Entity.html#addTimer>addTimer</a>函数添加。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>timerHandle</i></span></td><td><span class="function_parameter_description">
定时器的id。
</span></td></tr>

<tr valign=top><td><span class="function_parameter_name"><i>userData</i></span></td><td><span class="function_parameter_description">
传进<a href="Entity.html">Entity</a>.<a href=Entity.html#addTimer>addTimer</a>的integer用户数据。
</span></td></tr>

</table>
</p>


<a name="onTeleportFailure"></a><p class="function_definition">
<span class="function_definition">def onTeleportFailure( <i>self</i> ):</span>
</p>

<div class="function_description">如果这个函数在脚本中有实现，当用户调用<a href=../../keywords.html#entity>Entity</a>.<a href=Entity.html#teleport>teleport</a>失败时该回调被调用。
</div>


<a name="onTeleportSuccess"></a><p class="function_definition">
<span class="function_definition">def onTeleportSuccess( <i>self, nearbyEntity</i> ):</span>
</p>

<div class="function_description">如果这个函数在脚本中有实现，当用户调用<a href=../../keywords.html#entity>Entity</a>.<a href=Entity.html#teleport>teleport</a>成功时该回调被调用。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>nearbyEntity</i></span></td><td><span class="function_parameter_description">&nbsp;这个参数由用户调用
    <a href=../../keywords.html#entity>Entity</a>.<a href=Entity.html#teleport>teleport</a>时给出。这是一个real实体。
<br><br>

</table>
</p>




<a name="onWriteToDB"></a><p class="function_definition">
<span class="function_definition">def onWriteToDB( <i>self, cellData</i> ):</span>
</p>

<div class="function_description">
<b>功能说明：</b><br><br>
如果这个函数在脚本中有实现，这个函数在实体数据将要写进数据库的时候被调用。
<br><br>
需要注意的是在该回调里调用writeToDB会导致无限循环。
</div>

<p>
<span class="function_parameter">参数：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">

<tr valign=top><td><span class="function_parameter_name"><i>cellData</i></span></td><td><span class="function_parameter_description">
包含将要存进数据库的cell属性。
<a href="Entity.html#cellData">cellData</a>是一个字典。
</span></td></tr>

</table>
</p>

<hr>
<h2>属性文档</h2>

<a name="cell"></a><p class="attribute_definition">
<span class="attribute_definition">cell</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
cell是用于联系cell实体的<a href=../../keywords.html#EntityCall>ENTITYCALL</a>。这个属性是只读的，且如果这个base实体没有关联的cell时属性是None。
<br><br>
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 <a href=../../keywords.html#EntityCall>ENTITYCALL</a>
</td></tr>
</table>
</p>

<a name="cellData"></a><p class="attribute_definition">
<span class="attribute_definition">cellData</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
cellData是一个字典属性。每当base实体没有创建它的cell实体时，cell实体的属性会保存在这里。
<br><br>
如果cell实体被创建，这些用到的值和<a href=#cellData>cellData</a>属性将被删除。除了cell实体在实体定义文件里指定的属性外，它还包含position, direction and
spaceID。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td><a href="CELLDATADICT.html">CELLDATADICT</a>
</td></tr>
</table>
</p>

<a name="className"></a><p class="attribute_definition">
<span class="attribute_definition">className</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
实体的类名。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读，string
</td></tr>
</table>
</p>

<a name="client"></a><p class="attribute_definition">
<span class="attribute_definition">client</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
client是用于联系客户端的EntityCall。这个属性是只读的，且如果这个base实体没有关联的客户端时属性是None。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 <a href=../../keywords.html#EntityCall>ENTITYCALL</a>
</td></tr>
</table>
</p>

<a name="databaseID"></a><p class="attribute_definition">
<span class="attribute_definition">databaseID</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
databaseID是实体的永久ID(数据库id)。这个id是uint64类型且大于0，如果是0则表示该实体不是永久的。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 int64
</td></tr>
</table>
</p>

<a name="databaseInterfaceName"></a><p class="attribute_definition">
<span class="attribute_definition">databaseInterfaceName</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
databaseInterfaceName是实体持久化所在的数据库接口名称，该接口名称在kbengine_defaults->dbmgr中配置。实体必须持久化过（databaseID>0）该属性才可用，否则返回空字符串。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 string
</td></tr>
</table>
</p>


<a name="id"></a><p class="attribute_definition">
<span class="attribute_definition">id</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
id是实体的对象id。这个id是一个整型，在base，cell和client相关联的实体之间是相同的。
这个属性是只读的。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>只读 int32
</td></tr>
</table>
</p>

<a name="isDestroyed"></a><p class="attribute_definition">
<span class="attribute_definition">isDestroyed</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
如果该<a href="Entity.html">Entity</a>实体已经被销毁了，这个属性为True。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>bool
</td></tr>
</table>
</p>

<a name="shouldAutoArchive"></a><p class="attribute_definition">
<span class="attribute_definition">shouldAutoArchive</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
这个属性决定了自动存档的策略。如果设为True，自动存档将可用，如果设为False，自动存档将不可用。
如果设为<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>，自动存档将在下一个预定的时间可用，
在下一次存档后，这个属性将置为False。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>
</table>
</p>

<a name="shouldAutoBackup"></a><p class="attribute_definition">
<span class="attribute_definition">shouldAutoBackup</span>
</p>

<div class="attribute_description">
<b>说明：</b><br><br>
这个属性决定了自动备份的策略。如果设为True，自动备份将可用，如果设为False，自动备份将不可用。
如果设为<a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>，自动备份将在下一个预定的时间可用，
在下一次备份后，这个属性将置为False。
</div>

<p>
<span class="attribute_type">类型：</span>
<table border=0 cellpadding=0 cellspacing=3 style="margin-left: 20px;">
<tr><td>True, False or <a href="../Modules/KBEngine.html">KBEngine</a>.<a href=KBEngine.html#NEXT_ONLY>NEXT_ONLY</a>
</td></tr>
</table>
</p>


<hr>
<p class="copyrightFooter">版权归KBEngine所有。</p>
</body>
</html>